#+TAGS: CLOCKIN(k) SUDO(s) CLIPBOARD(c) TRUNCATE(e)
#+SEQ_TODO: TODO TEST DONE
* Tutorial
** Text manipulation
** Rectangle Mode
*** Delete "C-x r d"
*** rectangle-mark-mode
*** cua-resize-rectangle-right
** Regex
*** Syntax
**** Double Quate
     CLOSED: [2015-11-23 সোম 22:07]
| PatternMatches                                  |
| "\([^"]+\)" capture text between double quotes. |
| "hello world"                                   |

*** Matching Newline ＆ Tab
**** To enter a new line, press 【Ctrl+q Ctrl+j】
**** To enter a Tab character, press 【Ctrl+q Tab ↹】
***  Boundary anchors
| \`…                           |
| Beginning of {string, buffer} |
| …\'                           |
| End of {string, buffer}       |
| \b                            |
| word boundary marker          |

** Clipboard [2/3]                                                :CLIPBOARD:
  - [ ] Meta clipboard-kill-ring-save
  - [X] clipboard-kill-region
  - [X] clipboard-yank
** M-x RET set-variable RET
** Cursor Movement and Location [16/16]
        - [X] arrow keys (if available)N/AMove cursor.
        - [X] C-abeginning-of-lineMove to beginning of line.
        - [X] C-eend-of-lineMove to end of line.
        - [X] C-fforward-charMove forward one character.
        - [X] C-bbackward-charMove backward one character.
        - [X] M-f forward-wordMove󿿿 forward one word.
        - [X] M-bbackward-wordMove backward one word.
        - [X] C-nnext-lineMove down a line (creating the next line, if necessary).
        - [X] C-pprevious-lineMove up a line.
        - [X] M-r move-to-window-lineMove to left margin, vertically centered in window.
        - [X] M-<beginning-of-bufferMove to top of buffer.
        - [X] M->end-of-bufferMove to end of buffer.
        - [X] M-x goto-chargoto-charRead a number and go to that buffer position (start = 1).
        - [X] M-x goto-line goto-line Read a number and go to that line (first line = 1).
        - [X] M-=count-lines-regionPrint number of lines in current region.
        - [X] C-x =what-cursor-postitionPrint character code, character position and column of the cursor location.
        - [ ] Setting Mark C-@ -> (c shfit 1 )
        - [ ] C-w . . Kill region. This deletes and puts the region into the kill ring.
        - [ ] C-y . . Yank. This inserts the last snippet from the kill ring.
        - [ ] M-y . . Cycle kill ring. Immediately after C-y, this replaces the yanked part by the other snippets in the kill ring.
        - [ ] M-w . . Save region into kill ring. Like C-w, but doesn't delete.
        - [ ] In short, you start selection like usual with C-spc, then kill region with C-x r k and paste/yank killed block with C-x r y
        - [ ] C-x b buffer RET
        - [ ] C-x 4 buffer RET - another window ( switch-to-buffer-other-window )
        - [ ] C-x 4 b buffer RET another frame
** Evaluate all code chunks below current header
It sounds like you want org-babel-execute-buffer or org-babel-execute-subtree (C-c C-v s).
** Emacs in Bash
emacs --batch --load ~/.emacs \
      --eval "(progn (require 'org-mobile) (org-mobile-push))"
** org updown M-S-<up> and M-S-<down>
* Lisp
** Elisp Cookbook
*** String
#+BEGIN_SRC elisp
(zerop (string-match "" ""))
(string-equal "A" "A")
(equal "AAA" "AAA")
(zerop (length "  "))
(length "  ")
(eq ""  "")
(eq "" (purecopy ""))
(eq "" (propertize "" 'face 'italic))
#+END_SRC

#+RESULTS:
: t

*** tutorial
#+BEGIN_SRC emacs-lisp
;;; test.el starts here

(defun ev(n) (if (= (% n 2) 0) "even" "odd"))
;;; C-u C-M-x C-u C-M-x
(defun hello(name)
  (let ((name (upcase name))) (message "Hello, %s!" name)))
(defun pick-a-word (n)
  (cond
   ((= n 1) "one")
   ((= n 2) "two")
   (t "hello")))

(defun factorial (n)
  (if (< n 1) 1 (* n (factorial (- n 1)) )))

(defun qs (list)
  (if (null list)
      '()
    (let* (pivot (car list))
      (rest (cdr list))
      (lesser (remove-if-not
               (lambda (x) (<= x pivot)) rest ))
      (greater (remove-if-not (lambda (x) (> x pivot) ) rest))
      (append (qs lesser) '( pivot) (qs greater))
      )))
(global-set-key (kbd "M-e") 'sort-lines)

(add-hook 'c-mode-common-hook (lambda () (local-set-key (kbd '<f5>) 'recompile)))
(defun insertlinebefor ()
  "insert line before"
  (interactive)
  (save-excursion (move-beginning-of-line 1)(newline)))
(global-set-key (kbd "C-S-m") 'insertlinebefor)

#+END_SRC
*** String vs Buffer txt
**** Substring
#+BEGIN_SRC elisp
  (substring "abcdefg" 0 3)
  (substring "abcdefg" -3 -1)
  (with-temp-buffer (insert "abcdefg")
                    (buffer-substring 2 4))
#+END_SRC
**** Start-with and ends-with predicates
#+BEGIN_SRC elisp
    (defun string/ends-with (s ending)
      " Return non-nil if string S ends with ENDING."
      (cond ((>= (length s)  (length ending))
             (let ((elength (length ending)))
               (string= (substring s (- 0 elength)) ending)))
            (t nil)))
    (string/ends-with "hello" "ll")
    (defun string/starts-with (s begins)
      "Return non-nil if string S starts with BEGINS."
      (cond ((>= (length s) (length begins))
             (string-equal (substring s 0  (length begins)) begins))
            (t nil)))
        (string/starts-with "ABC" "A")
      (defun string/ends-withmac (string suffix)
      "Return t if STRING ends with SUFFIX."
      (and (string-match (rx-to-string `(: ,suffix eos) t) string) t))
      (string/ends-withmac "hello" "llo")

    (defun string/starts-with (string prefix)
    "Return t if STRING starts with prefix."
    (and (string-match (rx-to-string `(: bos ,prefix) t) string) t))
#+END_SRC
**** Processing characters
#+BEGIN_SRC elisp
  (defun string/reverse (str)
    "Reverse the str where str is a string"
    (apply #'string (reverse (string-to-list str))))
(string/reverse "hello World")
#+END_SRC
**** Looking at characters in a temporary buffer
#+BEGIN_SRC elisp
  (with-temp-buffer
    (insert "abcdefg")
    (goto-char (point-min))
    (while (not (= (char-after) ?b)) (forward-char)) (point))
#+END_SRC
**** Trim whitespace
#+BEGIN_SRC elisp
(setq test-str "abcdefg   ")
(when (string-match "[ \t]*$" test-str)
(message (concat "[" (replace-match "ABC" nil nil test-str) "]")))
#+END_SRC
** find file
#+BEGIN_SRC elisp
(defun gtd ()
  (interactive)
  (find-file "~/org/gtd.org")
  )
#+END_SRC

#+RESULTS:
: gtd

** For troubled network auto save frequently
#+BEGIN_SRC elisp
(setq auto-save-interval 1
          auto-save-timeout 1)
#+END_SRC

#+RESULTS:
: 1

*** Automatically save your changes after an customizable interval
I really like this idea, because it’s dumb to make me hit C-x C-s all the time because of technical details of the computer’s architecture, and almost everything I edit is under version control anyway. I like using auto-save-hook, and that seems to work well, but I want to save all the buffers, because if I switch away from a buffer before it autosaves, I want it to get saved when things next get saved after that. So I combined parts of the two above solutions (this is the first elisp code I’ve written, could have glaring problems)
#+BEGIN_SRC elisp
  (defun full-auto-save ()
    (interactive)
    (save-excursion
    (dolist (buf (buffer-list))
      (set-buffer buf)
      (if (and (buffer-file-name) (buffer-modified-p))
          (basic-save-buffer)))))
(add-hook 'auto-save-hook 'full-auto-save)
#+END_SRC
** Keyboard Macro [8/9]                                               :MACRO:
        - [X] f3 start
        - [X] f4 end
        - [X] c-x e - execute
        - [X] c-x c-k SPC - debug
        - [X] c-x c-k n - name exp name: abc_mac
        - [X] in .emacs.d - insert-kbd-macro abc_mac
        - [X] repeat infinate c-u 0 c-x e
        - [X] recent commands c-x c-k l
** Line Truncate                                                   :TRUNCATE:
*** Elisp Command
Note: Need to reset Emacs to get truncate effect
or use [[Command]] directly
#+BEGIN_SRC elisp
(setq-default truncate-lines nil)
#+END_SRC
#+RESULTS:
*** Command
****  M-x set-variable truncate-lines nil.
** How can I set a deadline on TODO for the last weekday of the month
#+BEGIN_SRC elisp
(defun last-working-day-deadline ()
  (interactive)
  (let* ((date (calendar-current-date))
  (day (calendar-extract-day date))
  (month (calendar-extract-month date))
  (year (calendar-extract-year date))
  (lastday (calendar-last-day-of-month month year)))
  ;; workdays have "names" of 1 2 3 4 or 5
  (while (not (memq (calendar-day-of-week (list month lastday year)) '(1 2 3 4 5)))
  (decf lastday))
 (org-deadline nil (format "%s-%s-%s" year month lastday))))
#+END_SRC
** show the Org-mode agenda on Emacs start-up
(add-hook 'after-init-hook 'org-agenda-list)
* Find Libarary
M-x find-library RET kmacro
M-x find-library RET edmacro
* Haskell
#+BEGIN_SRC haskell
   increasing :: (Ord a) => [a] -> Bool
   increasing [] =  True
   increasing [x] = True
   increasing (x:y:ys) = x <= y && increasing(y:ys)
   increasing [5]
#+END_SRC

#+RESULTS:
: Prelude Data.List System.IO System.Process>
: <interactive>:250:1: Not in scope: ‘increasing’
